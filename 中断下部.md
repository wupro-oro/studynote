# 为什么中断要分为上下部
- 由于中断随时可以发生，所以必须保证中断处理程序可以快速执行，但中断处理程序可能又处理大量的任务，两者之间存在矛盾，所以一般会把中断处理的过程分为两部分：上半部和下半部
- 上半部也叫硬件中断，是通常意义上的中断处理程序，用来接收中断，和简单的、有时限的处理工作，例如对中断接收后进行应答或复位硬件等需要在所有中断被禁止的情况下完成工作。而其他的允许稍后完成的工作，则会推迟到下半部在合适的时间完成。Linux有许多机制来实现下半部，其中一种就是软中断。(软中断、tasklet、工作队列)[中断下半部的三种机制](https://blog.csdn.net/FreeeLinux/article/details/54266843)
- [Linux内核学习笔记（十）中断处理的下半部](https://www.huliujia.com/blog/1553798b9dd8620c2fb8839ea0fda9cb2490d83d/)
- 举个例子(**下半部**)：对于网卡的中断处理，上半部会执行通知硬件、拷贝网络数据报到内存并继续读取新数据包，这些重要、紧急且与硬件相关的工作，因为网卡接收的网络数据包的缓存大小通常是固定的、有限的、一旦被延迟可能造成缓存溢出。而数据包的处理等操作，则由下半部来完成。**(延缓的耗时操作)**
# 各种机制的比较
| 下半部   | 上下文 | 顺序执行保障                               |
| -------- | ------ | ------------------------------------------ |
| 软中断   | 中断   | 随意同类型都可以在**不同**的处理器同时执行 |
| tasklet  | 中断   | 同类型不能同时执行                         |
| 工作队列 | 进程   | 不保障，可能被调度和抢占                                           |

## 软中断
- 适用于任务推后到进程上下文完成，可以休眠
- **软中断不能被另外一个软中断抢占**！**唯一可以抢占软中断的是中断处理程序**所以软中断允许响应中断。虽然不能在本处理器上抢占，但是其他的软中断甚至同类型可以再其他处理器上同时执行。由于这点，所以**对临界区需要加锁保护。**
- 软中断留给对时间要求最严格的下半部使用。目前只有网络，内核定时器和 tasklet 建立在软中断上
## tasklet
- 特点： tasklet本身是基于软中断实现，优先级是高于进程而低于硬件中断，所以tasklet对应的延后处理函数不能进行休眠操作，tasklet对应的延后处理函数执行原先中断处理函数中毕竟耗时和不紧急的内容。
- 任务接口简单，支持中断响应，但有同种类型不能同时执行的限制
- 这第二种机制是基于软中断实现的，灵活性强，动态创建的下半部实现机制。两个不同类型的 tasklet 可以在不同处理器上运行，但相同的不可以，可以通过代码动态注册。
- 在 SMP 上，调用 tasklet 是会检测 TASKLET_STATE_SCHED 标志，如果同类型在运行，就退出函数。tasklet 由于是基于软中断实现的，所以也允许响应中断。但不能睡眠（我认为不能睡眠原因是它们内部有 spin lock）。

### 实现中断下半部处理
- 在设备抽象中定义一个tasklet结构体
```c 
struct tasklet_struct task
```
- 在函数入口初始化tasklet并与处理函数绑定
```c
tasklet_init(&task,task_fun,data); //将处理函数和 tasklet 对象绑定
```
- 再自定义一个task函数
```c
void my_tasklet_func(unsigned long); //下半部要做的事情
```
- 形参是初始化时的数据
- 在中断处理函数中调度小任务执行
```c
tasklet_schedule(&task); //调度
```


## 工作队列 
-   linux 中 workqueue 机制为了简化内核线程的创建  
通过调用 workqueue 接口就能创建内核线程  
工作队列可以把工作推迟后交由一个内核线程去执行,也就是说,这个工作队列的下半部可在进程上下文执行  
(可以重新调度甚至休眠) ,在一个独立的进程环境下运行的.
- 提供的执行顺序保障最少，支持中断响应，由于同类型软中断在其他处理器可同时执行，所以要采取措施保护共享数据。
- 将下半部功能交由内核线程执行，有着线程上下文环境，可以睡眠。  
提供接口把需要推后执行的任务排列到队列里，提供默认的工作者线程处理排到队列里的下半部工作。
- 工作队列实际上是一个链表，工作线程作为死循环，链表空时休眠，不空是执行每一个工作。

### 实现中断下半部处理
-   在设备抽象中定义一个工作队列结构体
```c
wait_queue_head_t wq_head;  //等待队列头
int have_data; 			    //表示当前是否有数据  1--有  0--无
struct work_struct work;    //工作队列
```
-   在函数入口初始化工作队列并与处理函数绑定
```c
INIT_WORK(&button_device->work, button_work_queue);
```
- 形参1为工作队列，形参2为自定义的处理函数
- 再定义一个处理函数
```c
void my_wq_func(struct work_struct *work);//下半部要做的事情
```
- 形参是初始化时的数据
- 在中断处理函数中调度工作队列执行
```c
schedule_work(&my_wq); //调度
```
- 再处理函数中调用唤醒队列函数
```c
wake_up_interruptible(&button_device->wq_head);
```
- 在read接口函数中判断是否有数据可用,条件不满足就休眠  
```c
wait_event_interruptible(button_device>wq_head,button_device->have_data);
```
