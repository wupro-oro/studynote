## ARM处理器的7种模式
- **用户模式**（USR）：正常程序执行模式，不能直接切换到其他模式
- **系统模式**（SYS）：运行操作系统的特权任务，与用户模式类似，但具有可以直接切换到其他模式等特权
- **快中断模式**（FIQ）：支持高速数据传输及通道处理，FIQ异常响应时进入此模式
- **中断模式**（IRQ）：用于通用中断处理，IRQ异常响应时进入此模式
- **管理模式**（SVC）：操作系统保护模式，系统复位和软件中断响应时进入此模式（由系统调用执行软中断SWI命令触发）
- **终止模式**（ABT）：用于支持虚拟内存和/或存储器保护，在ARM7TDMI没有大用处
- **未定义模式**（UND）支持硬件协处理器的软件仿真，未定义指令异常响应时进入此模式

**除用户模式外，其余6种工作模式都属于特权模式  
    特权模式中除了系统模式以外的其余5种模式称为异常模式  
    大多数程序运行于用户模式  
    进入特权模式是为了处理中断、异常、或者访问被保护的系统资源**
## Linux内核中断编程之顶半部特点
- 顶半部就是做原先中断处理函数中比较紧急、耗时较短的内容，一旦硬件中断触发，CPU首先执行顶半部，执行时间非常快，执行完会立即释放CPU资源给其他任务使用，CPU在执行期间不允许发生CPU资源的切换，也就能踏踏实实的执行顶半部任务，顶半部本质就是中断处理函数，只是将原先中断处理中的最紧要、耗时最短的内容留下了而已。

## Linux中断编程之底半部特点
- 底半部做原先中断处理函数中比较耗时且不紧急的内容，CPU会在“适当”的适合去执行底半部的任务（当CPU执行底半部的时候，底半部的优先级势必是当前最高的），但是CPU在执行期间如果再次遇到一个高优先级的任务到来，那么势必会抢走底半部的CPU资源，等到高优先级的任务执行完毕后再将CPU资源还给底半部，底半部继续进行处理，底半部本质就是延后执行的一种手段而已。
如果仅仅单纯将某个事件延后执行，可以利用底半部机制来实现，底半部实现方法有三种：
- tasklet
- 工作队列
- 软中断
## 中断处理过程
![[中断详解.png]]
- 初始化
	- 设置中断源，让其产生中断
	- 设置中断控制器(屏蔽，优先级)
	- 设置CPU总开关(开中断)
- 定义好中断处理程序
- 产生中断
	- (以按键为例)按键按下-->中断控制器-->CPU
- CPU 每执行完一条指令都会检查有无中断，产生中断异常
- 发现中断/异常产生,开始处理 对于不同的异常，跳转到不同的地址指向程序去执行(**异常向量表**)
- 调用指向的程序
	- 根据不同的异常有不同的地址，调到某一个函数去执行
		- 流程
		- 保护现场
		- 处理中断异常-->分辨中断源-->再调用不同的中断处理函数-->例如：按键中断处理、网卡、触摸屏...等等
- **小结**
- 中断是一种异常处理 , arm有一个异常处理体系   异常向量表
- 中断有多个中断源 有一个中断向量表
- rk3399 有一个中断控制器CCI-500 中断源分类  四类   主要我们用 SPI类

## [[中断驱动框架]]
- [Linux驱动开发——中断编程之顶半部与底半部机制（1）](https://blog.51cto.com/u_6043682/3705947)
- Linux内核任务优先级划分
- 硬件中断的优先级高于软中断。
- 软中断的优先级高于进程。
- 进程之间也存在优先级，高优先级的进程和低优先级的进程。
- 软中断同样具有优先级之分，但是硬件中断并没有优先级之分，先到先处理。当高优先级任务占用CPU资源的适合，其他进程会进入“休眠”，但是中断的世界里是没有休眠的，并且中断不参与进程的调度。中断的世界没有休眠，那么对中断的使用要求就很高了，越是高优先级的中断任务，那么对其处理时间就越要求短，如果高优先级任务长期占有CPU资源自然会导致延误很多其他中断或者进程的处理，所以就有了Linux中断编程中的顶半部和底半部机制了。
## [[中断下部]]
